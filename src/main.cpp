#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cstdint>
#include <cstdlib>
#include <algorithm>
using namespace std;

// Simple generator: reads a mask file (text with rows of 0/1 characters),
// and emits ARMLite assembly that for each frame shifts the black pixels horizontally.

bool read_mask(const string &path, vector<string> &rows) {
    ifstream in(path);
    if (!in) return false;
    string line;
    while (getline(in, line)) {
        if(line.size()==0) continue;
        // strip possible whitespace
        string s;
        for(char c: line) if(c=='0' || c=='1') s.push_back(c);
        if(!s.empty()) rows.push_back(s);
    }
    return true;
}

int main(int argc, char **argv) {
    string mask_path = "mask.txt";
    string out_path = "bad-apple.asm";
    int frames = 64; // number of shifted frames
    if (argc >= 2) mask_path = argv[1];
    if (argc >= 3) out_path = argv[2];
    if (argc >= 4) frames = stoi(argv[3]);

    vector<string> rows;
    if (!read_mask(mask_path, rows)) {
        cerr << "Failed to read mask file: " << mask_path << "\n";
        return 1;
    }
    int h = (int)rows.size();
    int w = h ? (int)rows[0].size() : 0;
    // target screen width/height (choose mid-res defaults mapping)
    const int screen_w = 64;
    const int screen_h = 48;

    vector<uint32_t> base_offsets;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            if (rows[y][x] == '1') {
                // place mask at top-left; compute byte offset from PixelScreen
                uint32_t offset = (uint32_t)((y * screen_w + x) * 4);
                base_offsets.push_back(offset);
            }
        }
    }

    // compute horizontal shifts (wrap-around) in bytes
    int max_dx = screen_w - w;
    if (max_dx < 1) max_dx = 1;
    vector<uint32_t> shifts;
    for (int f = 0; f < frames; ++f) {
        int dx = (f % (max_dx+1));
        shifts.push_back((uint32_t)(dx * 4));
    }

    // emit assembly
    ofstream out(out_path);
    out << "; Generated by frame2arm (C++ generator)\n";
    out << "; Mask: " << mask_path << "  mask size=" << w << "x" << h << "  pixels=" << base_offsets.size() << "\n";
    out << "    MOV R0, #0x000000    ; black\n";
    out << "    MOV R1, #.PixelScreen\n";
    out << "    MOV R2, #base_offsets    ; address of base offsets list\n";
    out << "    MOV R3, #" << base_offsets.size() << "    ; number of black pixels in mask\n";
    out << "    MOV R4, #shifts\n";
    out << "    MOV R5, #" << frames << "    ; frames count\n";
    out << "    MOV R6, #0    ; current frame index\n";
    out << "frame_loop:\n";
    out << "    MOV R7, R6\n";
    out << "    LSL R7, R7, #2      ; R7 = R6 * 4 (byte offset into shifts)\n";
    out << "    ADD R7, R7, R4      ; R7 = &shifts + index*4\n";
    out << "    LDR R8, [R7]        ; R8 = shift in bytes for this frame\n";
    out << "    MOV R9, R2          ; pointer to base_offsets array\n";
    out << "    MOV R10, #0         ; pixel loop idx\n";
    out << "pixel_loop:\n";
    out << "    LDR R11, [R9]       ; base offset for pixel\n";
    out << "    ADD R11, R11, R8    ; add frame shift\n";
    out << "    STR R0, [R1+R11]    ; draw black pixel\n";
    out << "    ADD R9, R9, #4      ; next base_offsets\n";
    out << "    ADD R10, R10, #1\n";
    out << "    CMP R10, R3\n";
    out << "    BLT pixel_loop\n";
    out << "    ADD R6, R6, #1\n";
    out << "    CMP R6, R5\n";
    out << "    BLT frame_loop\n";
    out << "    HALT\n";
    out << "\n";
    out << ".DATA\n";
    out << "base_offsets:\n";
    for (auto v: base_offsets) out << "    .WORD " << v << "\n";
    out << "\n";
    out << "shifts:\n";
    for (auto s: shifts) out << "    .WORD " << s << "\n";

    out.close();
    cout << "Wrote assembly to " << out_path << " (" << base_offsets.size() << " pixels, " << frames << " frames)\n";

    return 0;
}
